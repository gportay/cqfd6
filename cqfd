#!/usr/bin/env bash
#
# cqfd - a tool to wrap commands in controlled Docker containers
#
# Copyright (C) 2016-2017,2023-2025 Gaël PORTAY
#               2015-2025           Savoir-faire Linux, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

set -e
set -o pipefail

PROGNAME=$(basename "$0")
VERSION=6
cqfd_user="${USER:-builder}"
cqfd_user_home="${HOME:-/home/$cqfd_user}"
cqfd_shell="${CQFD_SHELL:-/bin/bash}"
# shellcheck disable=SC2162
read -a cqfd_docker <<<"${CQFD_DOCKER:-docker}"
cqfd_docker_gid="${CQFD_DOCKER_GID:-0}"
cqfd_cachedir="${CQFD_CACHE:-${XDG_CACHE_HOME:-$HOME/.cache}/cqfd}"

## usage() - print usage
# stdout: the usage
usage() {
	cat <<EOF
Usage: $PROGNAME [OPTIONS] [COMMAND] [COMMAND OPTIONS] [ARGUMENTS]

Options:
    --release            Release software.
    -f <file>            Use file as config file (default .cqfdrc).
    -d <directory>       Use directory as cqfd directory (default .cqfd).
    -w <directory>       Use directory as working directory (default parent of
                         .cqfd).
    -C <directory>       Change to the specified working directory.
    -b <flavor_name>     Target a specific build flavor.
    -q                   Turn on quiet mode.
    -v or --version      Show version.
    --verbose            Increase the script's verbosity.
    -h or --help         Show this help text.

Commands:
    init                 Initialize project build container.
    deinit               Deinitialize project build container.
    ls                   List build containers.
    gc                   Cleanup unused build containers.
    exec cmd [args]      Run argument(s) inside build container.
    flavors              List flavors from config file to stdout.
    run [cmdstring]      Run argument(s) inside build container.
    release [cmdstring]  Run argument(s) and release software.
    shell [shargs]       Run shell command inside build container.
    help                 Show this help text.

    By default, the 'run' command is assumed, with the default
    command string configured in your .cqfdrc (see build.command).

Command options for run / release:
    -c <args>            Append args to the default command string.

    cqfd is Copyright (C) 2015-2025 Savoir-faire Linux, Inc.

    This program comes with ABSOLUTELY NO WARRANTY. This is free
    software, and you are welcome to redistribute it under the terms
    of the GNU GPLv3 license; see the LICENSE for more informations.
EOF
}

## cfg_parser() - parse ini-style config files
# Will parse a ini-style config file, and evaluate it to a bash array.
#   Ref: https://ajdiaz.wordpress.com/2008/02/09/bash-ini-parser/
#        by Andrés J. Díaz - License: MIT
# $1: path to ini file
cfg_parser() {
	local ini

	mapfile -t ini <"$1"                                 # convert to line-array
	ini=("${ini[@]//[/\\[}")                             # escape [
	ini=("${ini[@]//]/\\]}")                             # escape ]
	ini=("${ini[@]//;*/}")                               # remove comments with ;
	ini=("${ini[@]/$'\t'=/=}")                           # remove tabs before =
	ini=("${ini[@]/=$'\t'/=}")                           # remove tabs after =
	ini=("${ini[@]/\ =/=}")                              # remove space before =
	ini=("${ini[@]/=\ /=}")                              # remove space after =
	ini=("${ini[@]/#\\[/$'\n}\nfunction cfg_section_'}") # convert section to function (1)
	ini=("${ini[@]/%\\]/ { :}")                          # convert section to function (2)
	ini+=("}")                                           # add the last brace
	ini[0]="${ini[0]/\}/}"                               # remove the first brace
	ini=("$(printf "%s\n" "${ini[@]}")")                 # reconvert to line-array
	eval "${ini[*]}"                                     # eval the result
}

## warn() - output warning
# $*: messages and variables shown in the message
warn() {
	echo "cqfd: warning: $*" >&2
}

## die() - exit when an error occured
# $*: messages shown in the error message
die() {
	echo "cqfd: fatal: $*" >&2
	exit 1
}

## debug() - print verbose messages
# $*: messages shown in the debug message
debug() {
	test -z "$CQFD_DEBUG" || echo "cqfd: debug: $*"
}

## image_is_running() - checks if image is running
# $1: the image name to check if running
image_is_running() {
	local ids
	mapfile -t ids < <("${cqfd_docker[@]}" ps --filter "ancestor=$1" --filter status=running --quiet)
	test "${#ids[@]}" -gt 0
}

## images() - list images
# stdout: the tag, the status, the path to Dockerfile, the Dockerfile hash and
#         the image hash
images() {
	local user
	local image
	local images

	# shellcheck disable=SC2001
	user="$(sed 's/[^0-9a-zA-Z\-]/_/g' <<<"$USER")"

	mapfile -t images < <("${cqfd_docker[@]}" images "cqfd_$user\_*" --format "{{.Repository}}")
	for image in "${images[@]}"; do
		local symlink

		# Remove registry if any
		image="${image##*/}"
		for symlink in "$cqfd_cachedir/${cqfd_docker[-1]}"/*/"$image"; do
			local array
			local hash
			local status
			local dockerfile
			local dockerfile_hash

			if [ ! -L "$symlink" ]; then
				continue
			fi

			# Split components to extract the Dockerfile hash
			IFS=_ read -r -a array <<<"${symlink##*/cqfd_"$user"_}"
			array=(cqfd "$user" "${array[@]}")
			hash="${array[-1]}"
			if [ "${#array[@]}" -gt 5 ]; then
				hash="${array[-2]}"
			fi

			# Get the Dockerfile path to compute the hash
			dockerfile="<none>"
			dockerfile_hash="<none>"
			if [ -e "$symlink" ]; then
				dockerfile="$(readlink "$symlink")"
				dockerfile_hash="$(sha256sum "$dockerfile" | cut -b 1-7)"
			fi

			# The symlink does not exist: image is Deleted
			if [ ! -e "$symlink" ]; then
				status="Deleted"
			# The Dockerfile hash mismatches: image is Outdated
			elif [ "$dockerfile_hash" != "$hash" ]; then
				status="Outdated"
			# The Dockerfile exists and hash matches,
			# and at least a container is running: image is Running
			elif image_is_running "$image"; then
				status="Running"
			# The Dockerfile exists and hash matches,
			# and no container is running: image is Ready
			else
				status="Ready"
			fi

			echo "$image" "$status" "$dockerfile" "dockerfile_hash" "$hash"
		done
	done
}

## list() - list images
# stdout: the tag, the status, and the path to Dockerfile, with header and
#         aligned columns
list() {
	local image
	local images
	local maxtag

	# Output header and look for the max tag length of images
	maxtag=""
	mapfile -t images < <(images)
	for image in "${images[@]}"; do
		local tag

		read -r tag _ <<<"$image"
		if [ "${#tag}" -gt "${#maxtag}" ]; then
			maxtag="$tag"
		fi
	done
	printf "%-${#maxtag}s %-8s %s\n" "TAG" "STATUS" "DOCKERFILE"

	# Output the images
	for image in "${images[@]}"; do
		local tag
		local status
		local dockerfile

		read -r tag status dockerfile _ <<<"$image"
		printf "%-${#maxtag}s %-8s %-7s %s\n" "$tag" "$status" "$dockerfile"
	done
}

## prune() - remove deleted and outdated images
prune() {
	local tags
	local image
	local images
	local symlink

	# List unused images
	mapfile -t images < <(images)
	for image in "${images[@]}"; do
		local tag
		local status

		# Append outdated and deleted image to list
		read -r tag status _ <<<"$image"
		if [ "$status" = "Deleted" ] ||
		   [ "$status" = "Outdated" ]; then
			tags+=("$tag")
		fi
	done

	# Remove unused images if any
	if [ "${#tags[@]}" -gt 0 ]; then
		local args=()

		# Append extra args from the .cqfdrc [build] section
		if [ "$build_docker_rmi_args" ]; then
			local array
			# shellcheck disable=SC2162
			read -a array <<<"$build_docker_rmi_args"
			args+=("${array[@]}")
		fi

		# Append extra args from $CQFD_EXTRA_RMI_ARGS
		if [ "$CQFD_EXTRA_RMI_ARGS" ]; then
			local array
			# shellcheck disable=SC2162
			read -a array <<<"$CQFD_EXTRA_RMI_ARGS"
			args+=("${array[@]}")
		fi

		# Remove image
		"${cqfd_docker[@]}" rmi --force "${args[@]}" "${tags[@]}"
	fi

	# Consolidate the database
	for symlink in "$cqfd_cachedir/${cqfd_docker[-1]}"/*/*; do
		local tag

		if [ ! -L "$symlink" ]; then
			continue
		fi


		# Remove if symlink is broken or if image does not exist
		tag="${symlink##*/}"
		if [ ! -e "$symlink" ] || ! image_exists_locally "$tag"; then
			rm "$symlink"
			rmdir --ignore-fail-on-non-empty "${symlink%/*}"
		fi
	done
}

## docker_pull_or_build() - initialize build container
docker_pull_or_build() {
	local args
	args=()

	# Suppress the build output
	if [ "$quiet" ]; then
		args+=(--quiet)
	fi

	# Pull the image
	# If custom image name is used, it is pulled pull by docker_run()
	if [ "$project_image" ] && [ ! "$project_custom_img_name" ] ; then
		args+=("$cqfd_image")

		debug executing: "${cqfd_docker[@]}" pull "${args[@]}"
		"${cqfd_docker[@]}" pull "${args[@]}"
		return
	fi

	# Append extra args from the .cqfdrc [build] section
	if [ "$build_docker_build_args" ]; then
		local array
		# shellcheck disable=SC2162
		read -a array <<<"$build_docker_build_args"
		args+=("${array[@]}")
	fi

	# Append extra args from $CQFD_EXTRA_BUILD_ARGS
	if [ "$CQFD_EXTRA_BUILD_ARGS" ]; then
		local array
		# shellcheck disable=SC2162
		read -a array <<<"$CQFD_EXTRA_BUILD_ARGS"
		args+=("${array[@]}")
	fi

	# Name the resulting image
	args+=(--tag "$cqfd_image")

	# Set the context
	if [ -z "$project_build_context" ]; then
		args+=("$(dirname "$cqfd_dockerfile")")
	else
		args+=("$project_build_context" --file "$cqfd_dockerfile")
	fi

	# Run command
	debug executing: "${cqfd_docker[@]}" build "${args[@]}"
	"${cqfd_docker[@]}" build "${args[@]}"

	# Cache image
	local file
	local hash
	file="$(realpath "$cqfd_dockerfile")"
	hash="$(sha256sum <<<"$PWD" | cut -b 1-64)"
	mkdir -p "$cqfd_cachedir/${cqfd_docker[-1]}/$hash"
	ln -sf "$file" "$cqfd_cachedir/${cqfd_docker[-1]}/$hash/$cqfd_image"
}

## image_exists_locally() - checks if image exists in the local image store
# $1: the image name to check
image_exists_locally() {
	"${cqfd_docker[@]}" image inspect "$1" &>/dev/null
}

## docker_rmi() - remove build container
docker_rmi() {
	local args
	args=()

	# Check if image is running
	if image_is_running "$cqfd_image"; then
		die "$cqfd_image: Image busy!"
	fi

	# Append extra args from the .cqfdrc [build] section
	if [ "$build_docker_rmi_args" ]; then
		local array
		# shellcheck disable=SC2162
		read -a array <<<"$build_docker_rmi_args"
		args+=("${array[@]}")
	fi

	# Append extra args from $CQFD_EXTRA_RMI_ARGS
	if [ "$CQFD_EXTRA_RMI_ARGS" ]; then
		local array
		# shellcheck disable=SC2162
		read -a array <<<"$CQFD_EXTRA_RMI_ARGS"
		args+=("${array[@]}")
	fi

	# Set the image to remove
	args+=("$cqfd_image")

	# Run command
	debug executing: "${cqfd_docker[@]}" rmi "${args[@]}"
	"${cqfd_docker[@]}" rmi "${args[@]}"

	# Remove image if cached
	if [ -e "$cqfd_dockerfile" ]; then
		local file
		local hash
		file="$(realpath "$cqfd_dockerfile")"
		hash="$(sha256sum <<<"$PWD" | cut -b 1-64)"
		rm --force "$cqfd_cachedir/${cqfd_docker[-1]}/$hash/$cqfd_image"
		rmdir --ignore-fail-on-non-empty "$cqfd_cachedir/${cqfd_docker[-1]}/$hash"
	fi
}

## docker_run() - run command string in build container
# $1: the command string to run
docker_run() {
	local args
	args=()

	# The image does not exist
	if ! image_exists_locally "$cqfd_image"; then
		# If custom image name is used, try to pull it before dying
		if [ "$project_custom_img_name" ]; then
			if ! "${cqfd_docker[@]}" pull "$cqfd_image" &>/dev/null; then
				die "Custom image couldn't be pulled, please build/upload it first"
			fi
		else
			die "The docker image doesn't exist, launch 'cqfd init' to create it"
		fi
	fi

	# Append extra args from the .cqfdrc [build] section
	if [ "$build_docker_run_args" ]; then
		local array
		# shellcheck disable=SC2162
		read -a array <<<"$build_docker_run_args"
		args+=("${array[@]}")
	fi

	# Append extra args from $CQFD_EXTRA_RUN_ARGS
	if [ "$CQFD_EXTRA_RUN_ARGS" ]; then
		local array
		# shellcheck disable=SC2162
		read -a array <<<"$CQFD_EXTRA_RUN_ARGS"
		args+=("${array[@]}")
	fi

	# Give access to all host devices
	args+=(--privileged)

	# Cleanup container after exit
	args+=(--rm)

	# Log nothing
	args+=(--log-driver=none)

	# Always keep stdin open
	args+=(--interactive)

	# Allocate a pty if stdin/err are connected to a tty
	if [ -t 0 ] && [ -t 2 ]; then
		args+=(--tty)
	fi

	# Terminate if using legacy variable
	if [ -n "$CQFD_EXTRA_VOLUMES" ]; then
		die "CQFD_EXTRA_VOLUMES is no more supported, use" \
		    "CQFD_EXTRA_RUN_ARGS=\"-v <local_dir>:<container_dir>\""
	fi
	if [ -n "$CQFD_EXTRA_HOSTS" ]; then
		die "CQFD_EXTRA_HOSTS is no more supported, use" \
		    "CQFD_EXTRA_RUN_ARGS=\"--add-host <hostname>:<IP_address>\""
	fi
	if [ -n "$CQFD_EXTRA_ENV" ]; then
		die "CQFD_EXTRA_ENV is no more supported, use" \
		    "CQFD_EXTRA_RUN_ARGS=\"-e <var_name>=<value>\""
	fi
	if [ -n "$CQFD_EXTRA_PORTS" ]; then
		die "CQFD_EXTRA_PORTS is no more supported, use" \
		    "CQFD_EXTRA_RUN_ARGS=\"-p <host_port>:<docker_port>\""
	fi

	# The user may set the user_extra_groups in the .cqfdrc
	# file to add groups to the user in the container.
	if [ -n "$build_user_extra_groups" ]; then
		local group
		local array
		# shellcheck disable=SC2162
		read -a array <<<"$build_user_extra_groups"
		for group in "${array[@]}"; do
			# optional groupd id specified ("name:123")
			if echo "$group" | grep -qE ":[0-9]+$"; then
				CQFD_GROUPS+=("$group")
			else
				id=$(awk -F: "\$1 == \"$group\" { print \$3 }" /etc/group)
				CQFD_GROUPS+=("$group:$id")
			fi
		done
	fi

	# Set HOME variable for the $cqfd_user, except if it was explicitly set
	# via CQFD_EXTRA_RUN_ARGS or docker_run_args
	if ! echo "$CQFD_EXTRA_RUN_ARGS $build_docker_run_args" |
	     grep -qE "(-e[[:blank:]]*|--env[[:blank:]]+)HOME="; then
		args+=(--env "HOME=$cqfd_user_home")
	fi

	if [ "$CQFD_NO_USER_SSH_CONFIG" != true ]; then
		args+=(--volume "$cqfd_user_home/.ssh:$cqfd_user_home/.ssh")
	fi

	if [ "$CQFD_NO_SSH_CONFIG" != true ]; then
		args+=(--volume /etc/ssh:/etc/ssh)
	fi

	if [ "$CQFD_NO_SSH_AUTH_SOCK" != true ] && [ "$SSH_AUTH_SOCK" ]; then
		args+=(--volume "$SSH_AUTH_SOCK:$cqfd_user_home/.sockets/ssh")
		args+=(--env "SSH_AUTH_SOCK=$cqfd_user_home/.sockets/ssh")
	fi

	if [ "$CQFD_NO_USER_GIT_CONFIG" != true ] && [ -f "$cqfd_user_home/.gitconfig" ]; then
		args+=(--mount "type=bind,src=$cqfd_user_home/.gitconfig,dst=$cqfd_user_home/.gitconfig")
	fi

	if [ "$CQFD_BIND_DOCKER_SOCK" = true ]; then
		args+=(--volume /var/run/docker.sock:/var/run/docker.sock)
	fi

	# Bind mount the project directory
	local workdir
	if ! workdir="$(realpath "$build_workdir")" ||
	   [ ! -d "$workdir" ]; then
		die "$build_workdir: Missing or not a directory!"
	fi
	cqfd_user_cwd="$workdir"
	args+=(--volume "$cqfd_user_cwd:$cqfd_user_cwd")

	# Create and bind mount the entrypoint
	tmp_entrypoint=$(mktemp /tmp/cqfd-entrypoint.XXXXXX)
	trap 'rm -f "$tmp_entrypoint"' EXIT
	make_entrypoint "$tmp_entrypoint"
	chmod 0755 "$tmp_entrypoint"
	args+=(--volume "$tmp_entrypoint:/bin/cqfd-entrypoint")
	args+=(--entrypoint "/bin/cqfd-entrypoint")

	# Set positional arguments
	args+=("$cqfd_image" "$1")

	# Run command
	debug executing: "${cqfd_docker[@]}" run "${args[@]}"
	"${cqfd_docker[@]}" run "${args[@]}"
}

## make_archive() - create a release package
make_archive() {
	local tar_opts
	local files
	local git_short
	local git_long
	local date_rfc3339
	local date_unix

	eval "files=($release_files)"
	if [ -z "${files[*]}" ]; then
		die ".cqfdrc: Missing or empty build.files property!"
	fi

	for file in "${files[@]}"; do
		if [ ! -e "$file" ]; then
			die "$file: Missing file!"
		fi
	done

	# template the generated archive's filename
	git_short=$(git rev-parse --short HEAD 2>/dev/null || echo unset)
	git_long=$(git rev-parse HEAD 2>/dev/null || echo unset)
	date_rfc3339=$(date +"%Y-%m-%d")
	date_unix=$(date +%s)

	# default name for the archive if not set
	if [ -z "$release_archive" ]; then
		release_archive="%Po-%Pn.tar.xz"
	fi

	# shellcheck disable=SC2001
	release_archive=$(echo "$release_archive" |
		sed -e 's!%%!%!g;
			s!%Gh!'"$git_short"'!g;
			s!%GH!'"$git_long"'!g;
			s!%D3!'"$date_rfc3339"'!g;
			s!%Du!'"$date_unix"'!g;
			s!%Po!'"$project_org"'!g;
			s!%Pn!'"$project_name"'!g;
			s!%Cf!'"$flavor"'!g;')

	# also replace variable names - beware with eval
	eval "release_archive=$release_archive"

	# setting tar_transform=yes will move files to the root of a tar archive
	if [ "$release_transform" = "yes" ]; then
		tar_opts+=('--transform' 's/.*\///g')
	fi

	# setting tar_options=x will pass the options to tar
	if [ "$release_tar_opts" ]; then
		local array
		# shellcheck disable=SC2162
		read -a array <<<"$release_tar_opts"
		tar_opts+=("${array[@]}")
	fi

	# support the following archive formats
	case "$release_archive" in
	*.tar.xz)
		XZ_OPT=-9 tar "${tar_opts[@]}" -cJf \
			"$release_archive" "${files[@]}"
		;;
	*.tar.gz)
		tar "${tar_opts[@]}" -czf \
			"$release_archive" "${files[@]}"
		;;
	*.zip)
		zip -q -9 -r "$release_archive" "${files[@]}"
		;;
	*)
		;;
	esac
}

## make_entrypoint() - generate in-container entrypoint
# $1: the path to the entrypoint
make_entrypoint() {
	cat >"$1" <<EOF
#!/bin/sh
# create container user to match expected environment

set -e

die() {
	echo "error: \$*" >&2
	exit 1
}

debug() {
	test -z "$CQFD_DEBUG" || echo "debug: \$*"
}

test_cmd() {
	command -v "\$1" >/dev/null 2>&1
}

test_su_session_command() {
	su --session-command true >/dev/null 2>&1
}

# Change to working directory
cd "$cqfd_user_cwd"

# Check if privileges are already dropped
uid="\$(id -u)"
if [ "\$uid" -ne 0 ]; then
	exec /bin/sh -c "\$1"
fi

# Check container requirements
test_cmd groupadd || { failed=1 && echo "error: Missing command: groupadd" >&2; }
test_cmd useradd || { failed=1 && echo "error: Missing command: useradd" >&2; }
test_cmd usermod || { failed=1 && echo "error: Missing command: usermod" >&2; }
test_cmd chown || { failed=1 && echo "error: Missing command: chown" >&2; }
test_cmd sudo && has_sudo=1 || test_cmd su ||
	{ failed=1 && echo "error: Missing command: su or sudo" >&2; }
test -n "\$failed" &&
	die "Some dependencies are missing from the container, see above messages."

# Check is su supports --session-command if not using sudo
test "\$has_sudo" = 1 || test_su_session_command && has_su_session_command=1

# Get full path to cqfd_shell interpreter
if ! shell=\$(command -v "$cqfd_shell"); then
	echo "$cqfd_shell: command not found" >&2
	exit 127
fi

# Add the host's user and group to the container, and adjust ownership
groupadd -og "${GROUPS[0]}" -f builders
useradd -s "\$shell" -oN -u "$UID" -g "${GROUPS[0]}" -d "$cqfd_user_home" "$cqfd_user"
mkdir -p "$cqfd_user_home"
chown "$UID:${GROUPS[0]}" "$cqfd_user_home"

# Add specified groups to cqfd_user
for g in ${CQFD_GROUPS[*]}; do
	group=\$(echo "\$g" | cut -d: -f1)
	gid=\$(echo "\$g" | cut -d: -f2)

	if [ -n "\$gid" ]; then
		# create group with provided id ("name:123")
		groupadd -og "\$gid" -f "\$group"
	fi

	usermod -a -G \$group $cqfd_user
done

# Add docker group as cqfd to cqfd_user
if [ "${cqfd_docker_gid:-0}" -gt 0 ]; then
	groupadd -og "$cqfd_docker_gid" -f cqfd
	usermod -a -G cqfd $cqfd_user
fi	

# Drop the root privileges and run providing command, using sudo if it exists
if [ -n "\$has_sudo" ]; then
	debug "Using \"sudo\" to execute command sh -c \"\$1\" as user \"$cqfd_user\""
	exec sudo -E -u $cqfd_user sh -c "\$1"
fi

# Or, using su with the option --session-command to create a new session
if [ -n "\$has_su_session_command" ]; then
	debug "Using \"su\" to execute session command \"\$1\" as user \"$cqfd_user\""
	exec su $cqfd_user -p --session-command "\$1"
fi

# Or finally, fallback using su with option -c
debug "Using \"su\" to execute command \"\$1\" as user \"$cqfd_user\""
exec su $cqfd_user -p -c "\$1"
EOF
}

## locate_project_dir() - locate directory with .cqfd upwards
# stdout: the path to the .cqfd parent directory
locate_project_dir() {
	local search_dir

	if [ -n "$CQFD_DIR" ]; then
		realpath "$CQFD_DIR/.."
		return
	fi

	search_dir="$PWD"
	while [ "$search_dir" != "/" ]; do
		if [ -d "$search_dir/.cqfd" ]; then
			realpath "$search_dir"
			return
		fi
		search_dir="$(readlink -f "$search_dir"/..)"
	done

	return 1
}

## load_config() - load build settings from cqfdrc
# $1: optional "flavor" of the build, is a suffix of command
load_config() {
	# get the project directory
	local project_dir
	if ! project_dir=$(locate_project_dir); then
		die ".cqfd: Missing project directory!"
	fi

	local workdir
	workdir="${CQFD_WORKDIR:-$PWD}"
	# make an absolute path and check if it is a directory
	if ! workdir="$(realpath "$workdir")" || \
	   [ ! -d "$workdir" ]; then
		die ".cqfd: Missing or not a directory!"
	fi

	local cqfddir
	cqfddir="${CQFD_DIR:-$project_dir/.cqfd}"
	# make an absolute path and check if it is a directory
	if ! cqfddir="$(realpath "$cqfddir")" || \
	   [ ! -d "$cqfddir" ]; then
		die ".cqfd: Missing or not a directory!"
	fi

	local cqfdrc
	cqfdrc="${CQFDRC_FILE:-$project_dir/.cqfdrc}"
	# make an absolute path and check if it is a file
	if ! cqfdrc="$(realpath "$cqfdrc")" || \
	   [ ! -f "$cqfdrc" ]; then
		die ".cqfdrc: Missing or not a file!"
	fi

	# parse cqfdrc file
	if ! cfg_parser "$cqfdrc"; then
		die ".cqfdrc: Invalid ini-file!"
	fi

	# generate dynamically the list of flavors based on the names of shell
	# functions reported by the builtin:
	#  - the cfg_section_ prefix is stripped
	#  - the build and project sections are stripped
	local flavors
	mapfile -t flavors < <(compgen -A function -X '!cfg_section_*')
	flavors=("${flavors[@]/cfg_section_/}")
	for i in "${!flavors[@]}"; do
		if [[ "${flavors[$i]}" =~ ^(build|project)$ ]]; then
			unset 'flavors[$i]'
		fi
	done
	# shellcheck disable=SC2178
	flavors="${flavors[*]}"

	# load the [project] section
	if ! cfg_section_project 2>/dev/null; then
		die ".cqfdrc: Missing project section!"
	fi

	# shellcheck disable=SC2154
	project_org="$org"
	# shellcheck disable=SC2154
	project_name="$name"
	# shellcheck disable=SC2154
	project_build_context="$build_context"
	# shellcheck disable=SC2154
	project_custom_img_name="$custom_img_name"
	# shellcheck disable=SC2154
	project_tag="$tag"
	# shellcheck disable=SC2154
	project_image="$image"

	# check for [project] org and name properties are set and are not empty
	if [ -z "$project_org" ] || [ -z "$project_name" ]; then
		die ".cqfdrc: Missing project.org or project.name properties"
	fi

	# load the [build] section
	if ! cfg_section_build 2>/dev/null; then
		die ".cqfdrc: Missing build section!"
	fi

	# build parameters may be overriden by a flavor defined in the
	# build section's 'flavors' parameter.
	local flavor="$1"
	if [ -n "$flavor" ]; then
		# load the [$flavor] section
		if ! cfg_section_"$flavor" 2>/dev/null; then
			die ".cqfdrc: Missing $flavor section!"
		fi
	fi

	# shellcheck disable=SC2128
	build_flavors="$flavors"
	# shellcheck disable=SC2154
	build_workdir="$workdir"
	# shellcheck disable=SC2154
	build_command="$command"
	# shellcheck disable=SC2154
	build_dockerfile="$dockerfile"
	# shellcheck disable=SC2154
	build_docker_build_args="$docker_build_args"
	# shellcheck disable=SC2154
	build_docker_run_args="$docker_run_args"
	# shellcheck disable=SC2154
	build_distro="$distro"
	# shellcheck disable=SC2154
	build_user_extra_groups="$user_extra_groups"
	# shellcheck disable=SC2154
	release_files="$files"
	# shellcheck disable=SC2154
	release_archive="$archive"
	# shellcheck disable=SC2154
	release_transform="$tar_transform"
	# shellcheck disable=SC2154
	release_tar_opts="$tar_options"

	# warn if using legacy variable custom_img_name
	if [ -n "$project_custom_img_name" ]; then
		warn "custom_img_name is deprecated, use either tag to name" \
		     "your image or image to pull an image from a registry."
		# backward compatibility if image= or tag= unspecified
		if [ ! "$project_image" ]; then
			project_image="$project_custom_img_name"
			# set default Dockerfile if dockerfile= unspecified
			if [ -z "$build_dockerfile" ]; then
				build_dockerfile="$cqfddir/${build_distro:-docker}/Dockerfile"
			fi
			# the Dockerfile does not exist
			if ! cqfd_dockerfile="$(cd "$project_dir" && \
				        	realpath "$build_dockerfile" 2>/dev/null)" || \
			   [ ! -f "$cqfd_dockerfile" ]; then
				die "$build_dockerfile: Missing Dockerfile!"
			fi
		fi
		if [ ! "$project_tag" ]; then
			project_tag="$project_custom_img_name"
		fi
	fi

	# set default image if image= unspecified
	cqfd_image="$project_image"
	if [ ! "$cqfd_image" ]; then
		local Un
		local Po
		local Pn
		local Dh
		local DH
		local Bd

		# set default Dockerfile if dockerfile= unspecified
		if [ -z "$build_dockerfile" ]; then
			build_dockerfile="$cqfddir/${build_distro:-docker}/Dockerfile"
		fi
		# the Dockerfile does not exist
		if ! cqfd_dockerfile="$(cd "$project_dir" && \
				        realpath "$build_dockerfile" 2>/dev/null)" || \
		   [ ! -f "$cqfd_dockerfile" ]; then
			die "$build_dockerfile: Missing Dockerfile!"
		fi

		# shellcheck disable=SC2001
		Un=$(sed 's/[^0-9a-zA-Z\-]/_/g' <<<"$USER")
		Po="$project_org"
		Pn="$project_name"
		Dh=$(sha256sum "$cqfd_dockerfile" | cut -b 1-7)
		DH=$(sha256sum "$cqfd_dockerfile" | cut -b 1-64)
		Bd="${build_distro:-docker}"
		# set default tag if tag= unspecified
		if ! [ "$project_tag" ]; then
			project_tag="cqfd_%Un_%Po_%Pn_%Dh"
			if [ "$build_distro" ]; then
				project_tag+="_%Bd"
			fi
		fi
		# shellcheck disable=SC2001
		cqfd_image=$(sed -e 's!%Un!'"$Un"'!g;
			             s!%Po!'"$Po"'!g;
			             s!%Pn!'"$Pn"'!g;
			             s!%Dh!'"$Dh"'!g;
			             s!%DH!'"$DH"'!g;
			             s!%Bd!'"$Bd"'!g;' <<<"$project_tag")
	fi

	# set the docker gid if the group exists
	if [ "$cqfd_docker_gid" -eq 0 ]; then
		local docker_group
		if IFS=: read -r -a docker_group < <(getent group docker); then
			local docker_users
			IFS=, read -r -a docker_users <<<"${docker_group[3]}"
			for user in "${docker_users[@]}"; do
				if [ "$user" = "$cqfd_user" ]; then
					cqfd_docker_gid="${docker_group[2]}"
					break
				fi
			done
		fi
	fi

	# use sudo if user is not in the docker group
	if [ "$CQFD_RUN_WITH_SUDO" = true ] && [ "$cqfd_docker_gid" -eq 0 ]; then
		cqfd_docker=(sudo "${cqfd_docker[@]}")
	fi
}

has_to_release=false
has_alternate_command=false
while [ $# -gt 0 ]; do
	case "$1" in
	help|-h|--help)
		usage
		exit
		;;
	version|-v|--version)
		echo "$VERSION"
		exit
		;;
	--verbose)
		export CQFD_DEBUG=true
		export BUILDKIT_PROGRESS=plain
		;;
	init)
		load_config "$flavor"
		docker_pull_or_build
		exit
		;;
	deinit)
		load_config "$flavor"
		docker_rmi
		exit
		;;
	ls)
		load_config "$flavor"
		list
		exit
		;;
	gc)
		load_config "$flavor"
		prune
		exit
		;;
	flavors)
		load_config
		echo "$build_flavors"
		exit
		;;
	-b)
		shift
		flavor="$1"
		;;
	-w)
		shift
		CQFD_WORKDIR="$1"
		;;
	-d)
		shift
		CQFD_DIR="$1"
		;;
	-f)
		shift
		CQFDRC_FILE="$1"
		;;
	-C)
		shift
		cd "$1"
		;;
	-q)
		quiet=true
		export BUILDKIT_PROGRESS=quiet
		;;
	--release)
		has_to_release=true
		;;
	exec)
		shift
		if [ "$#" -lt 1 ]; then
			usage
			die "exec: Missing arguments!"
		fi
		load_config "$flavor"
		command_string="${*@Q}"
		docker_run "$command_string"
		exit
		;;
	run|release)
		if [ "$1" = "release" ]; then
			has_to_release=true
		fi

		shift

		# No more args? run default command
		[ "$#" -eq 0 ] && break

		# -c appends following args to the default command
		if [ "$1" = "-c" ]; then
			shift

			if [ "$#" -lt 1 ]; then
				usage
				die "run -c: Missing arguments!"
			fi
			break
		fi

		# Run alternate command
		has_alternate_command=true
		break
		;;
	sh|ash|dash|bash|ksh|zsh|csh|tcsh|fish|shell)
		if [ "$1" != "shell" ]; then
			cqfd_shell="$1"
		fi
		shift
		load_config "$flavor"
		command_string="$cqfd_shell"
		if [ "$#" -gt 0 ]; then
			command_string+=" ${*@Q}"
		fi
		docker_run "$command_string"
		exit
		;;
	*)
		usage
		die "$1: Invalid command!"
		;;
	esac
	shift
done

load_config "$flavor"

if ! $has_alternate_command && [ -n "$*" ] && [ -z "$build_command" ]; then
	warn ".cqfdrc: Missing or empty build.command property!"
fi

if $has_alternate_command; then
	build_command="$*"
elif [ -n "$*" ]; then
	build_command+=" $*"
fi

if [ -z "$build_command" ]; then
	die ".cqfdrc: Missing or empty build.command property!"
fi

docker_run "$build_command"

if $has_to_release; then
	make_archive
fi
